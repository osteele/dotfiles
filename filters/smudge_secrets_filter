#!/usr/bin/env ruby

require 'shellwords'
require 'yaml'

def die(msg)
  STDERR.puts msg
  exit 1
end

# TODO DRY /w clean_secrets_filter
FNAME = ARGV[0]
SECRETS_PATH = `git config filter.secrets.file`.chomp
REPO_NAME = [
  `git config filter.secrets.reponame`.chomp,
  File.basename(`git rev-parse --show-toplevel`.chomp)
].reject(&:empty?).first
die "git config filter.secrets.file not set; skipping filter" if SECRETS_PATH.empty?
die "File #{SECRETS_PATH} not found; skipping filter" unless File.exists? SECRETS_PATH

secrets = YAML.load_file(SECRETS_PATH).keep_if do |key, v|
  key = "**/#{key}" unless key[0] == '/'
  File.fnmatch(key, FNAME)
end.values.inject(&:merge)

matcher = /\b(#{secrets.keys.map {|k| Regexp.quote k}.join('|')})\b/ if secrets

STDIN.each do |line|
  if matcher and line =~ matcher
    name = $1
    key = "dotfile-secrets:#{secrets[name]}"
    keychain_keys = ['-a', ENV['USER'], '-c', 'gitf', '-C', 'gitf', '-D', 'git filter secret', '-l', secrets[name]]
    saved_secret = `#{Shellwords.join(['security', 'find-generic-password', '-w'] + keychain_keys)}`.chomp
    if $?.exitstatus == 0
      line = line.gsub(/\$secret\(#{name}\)/, saved_secret)
      STDERR.puts "smudged #{name}" if ENV['DEBUG_GIT_SECRETS']
    else
      STDERR.puts "Warning: #{$1} not smudged; no entry in keychain for #{keychain_keys}"
    end
    puts line
  elsif line =~ /\$secret\(\S+?\)/
    STDERR.puts "Warning: #{$1} not smudged; no entry in #{SECRETS_PATH}"
  else
    puts line
  end
end
